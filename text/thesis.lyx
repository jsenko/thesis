#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass fithesis2
\begin_preamble

%\newcommand*{\foo}{foo}

%\bibliographystyle{unsrtnat}

%\usepackage[pdftex]{hyperref}
%\lstset{basicstyle=\ttfamily}
%\newcommand{\TitlePages}{\ThesisTitlePage\FrontMatter}
%\hyphenation{de-bug-ging}
%\usepackage{listings}

\usepackage{amsfonts}
\usepackage{framed}
\end_preamble
\options 11pt,oneside,final
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Formal design of a distributed hash table
\end_layout

\begin_layout Subtitle
Master's thesis
\end_layout

\begin_layout Author
Jakub Senko
\end_layout

\begin_layout AuthorIsWoman
false
\end_layout

\begin_layout University
Masaryk University
\end_layout

\begin_layout Faculty
Faculty of Informatics
\end_layout

\begin_layout Logo
fi-logo
\end_layout

\begin_layout Advisor
RNDr.
 Vojtěch Řehák, Ph.D.
\end_layout

\begin_layout ThesisDate
Brno 2016
\end_layout

\begin_layout ThesisLanguage
en
\end_layout

\begin_layout ThesisDeclaration
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DeclarationText
\end_layout

\begin_layout Plain Layout


\backslash
AdvisorName
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout ThesisThanks
I would like to thank...
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
This thesis is focused on a design of a distributed hash table model and
 formal verification of its behaviour under failure conditions [using PlusCal/TL
A+ languages].
 The model matches algorithms and protocols used in the Infinispan project.
 Advantages and limitations of the model and the used technique are described.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Keywords
formal software verification, model checking, distributed hash table, Infinispan
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
MainMatter
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset


\end_layout

\begin_layout Standard
Testing is an integral part of software development - Several types of testing
 - Model checking - Having a proper model can be beneficial during the design
 and analysis phases, because it helps developers to catch potential design
 errors, especially in complex concurrent and distributed systems.
 - There are several projects at Red Hat where this is important.
 - One of these is Infinispan, a its core a distributed key-value storage.
 Having a model of a hash-table with the same basic design would help developers
 to prevent design errors.
 - This thesis was motivated by a successful use of model checking tools
 for development of Amazon AWS S3 product and is aimed to provide benefits
 of these techniques to Infinispan developers.
 
\end_layout

\begin_layout Chapter
Model Checking
\end_layout

\begin_layout Standard
In this chapter, [motivation, considerations] overview of the model checking
 techniques is presented.
\end_layout

\begin_layout Section
System Verification
\end_layout

\begin_layout Standard
Techniques:
\end_layout

\begin_layout Section
Characteristics of Model Checking
\end_layout

\begin_layout Standard
Model checking is an automated technique that, given a finite-state model
 of a system and a formal property, systematically checks whether this property
 holds for (a given state in) that model.
\end_layout

\begin_layout Standard
TODO:
\end_layout

\begin_layout Itemize
system specification
\end_layout

\begin_layout Itemize
Comparison to other testing & verification techniques
\end_layout

\begin_layout Itemize
Disadvantages (state explosion, model realism - Any verification using model-bas
ed techniques is only as good as the model of the system.)
\end_layout

\begin_layout Section
Transition systems
\end_layout

\begin_layout Standard
Transition systems are often used in computer science as models to describe
 the behavior of systems.
 They are basically directed graphs where nodes represent states, and edges
 model transitions, i.e., state changes.
 We will use the following formal definition of the TS [cit]:
\end_layout

\begin_layout Standard
A transition system (TS) is a tuple 
\begin_inset ERT
status open

\begin_layout Plain Layout

$(S,Act,
\backslash
to,I,AP,L)$
\end_layout

\end_inset

 where
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

 is a set of states, 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$Act$
\end_layout

\end_inset

 is a set of actions, 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
to 
\backslash
in S 
\backslash
times Act 
\backslash
times S$
\end_layout

\end_inset

 is a transition relation,
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$I 
\backslash
in S$
\end_layout

\end_inset

 is a set of initial states,
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$AP$
\end_layout

\end_inset

 is a set of atomic propositions,
\end_layout

\begin_layout Itemize
and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$L: S 
\backslash
to 2^{AP}$
\end_layout

\end_inset

 is a labeling function.
\end_layout

\begin_layout Standard
TS is called finite if 
\begin_inset ERT
status open

\begin_layout Plain Layout

$S$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$Act$
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout

$AP$
\end_layout

\end_inset

 are finite.
 
\end_layout

\begin_layout Standard
As an example, consider an hour-clock.
 It may be represented by 12 different states, with transitions representing
 actions the clock takes.
 This includes incrementing the counter, or overflowing from ,,12
\begin_inset Quotes erd
\end_inset

 to ,,1
\begin_inset Quotes erd
\end_inset

 state.
 In the conventional (and isolated) computer system, the states correspond
 to every possible contents of the memory and internal state of the processor.
 
\end_layout

\begin_layout Standard
The transition system may resemble other formalisms from computational theory,
 such as a non-deterministic finite state machine.
 However, there are important distinctions [cit, wiki]:
\end_layout

\begin_layout Itemize
The set of states is not necessarily finite, or even countable,
\end_layout

\begin_layout Itemize
the set of transitions is not necessarily finite, or even countable,
\end_layout

\begin_layout Itemize
there are no initial or final states defined.
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Standard
The notion of the labeling function is very important, since it allows for
 expressing formal assertions about states.
 For instance 
\begin_inset ERT
status open

\begin_layout Plain Layout

$[hour = 12]$
\end_layout

\end_inset

 is a labeling for a valid clock state, while 
\begin_inset ERT
status open

\begin_layout Plain Layout

$[hour > 12]$
\end_layout

\end_inset

 is not.
 The function 
\begin_inset ERT
status open

\begin_layout Plain Layout

$L$
\end_layout

\end_inset

 relates a set 
\begin_inset ERT
status open

\begin_layout Plain Layout

$L(s) 
\backslash
in 2^{AP}$
\end_layout

\end_inset

 of atomic propositions to any state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$s$
\end_layout

\end_inset

.
 It intuitively stands for exactly those atomic propositions 
\begin_inset ERT
status open

\begin_layout Plain Layout

$a 
\backslash
in AP$
\end_layout

\end_inset

 which are satisfied by state 
\begin_inset ERT
status open

\begin_layout Plain Layout

$s$
\end_layout

\end_inset

.
 Given that 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset

 is a propositional logic formula, then s satisfies the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset

 if the evaluation induced by 
\begin_inset ERT
status open

\begin_layout Plain Layout

$L(s)$
\end_layout

\end_inset

 makes the formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset

 true; that is: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$s 
\backslash
models 
\backslash
Phi$
\end_layout

\end_inset

 iff 
\begin_inset ERT
status open

\begin_layout Plain Layout

$L(s) 
\backslash
models 
\backslash
Phi$
\end_layout

\end_inset

.
 This enables reasoning about the entire TS using 
\emph on
temporal logic formulas
\emph default
.
\end_layout

\begin_layout Section
Executions and Behaviors
\end_layout

\begin_layout Standard
We represent the execution (or behavior
\begin_inset Foot
status open

\begin_layout Plain Layout
This terminology is used in the TLA+ specification, and is interchangeble
 with ,,execution
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

) of a system as a sequence of states (and actions).
 We specify a system by providing a set of executions representing a correct
 behavior of the system [cit].
 For example
\begin_inset Foot
status open

\begin_layout Plain Layout
For convenience, an element of the transition relation may be expressed
 as an arrow between two states, labeled with the action from 
\begin_inset ERT
status open

\begin_layout Plain Layout

$Act$
\end_layout

\end_inset

.
\end_layout

\end_inset

,
\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
dots 
\backslash
to^{tick} [hour = 1] 
\backslash
to^{tick} [hour = 2] 
\backslash
to^{tick} 
\backslash
dots 
\backslash
to^{tick} [hour = 12] 
\backslash
to^{tick} [hour = 1] 
\backslash
to^{tick} 
\backslash
dots$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
More formally, execution is an 
\emph on
initial
\emph default
 and 
\emph on
maximal
\emph default
 execution 
\emph on
fragment
\emph default
.
 Execution fragment is an alternating sequence of states and actions ending
 with a state.
 Maximal means that the fragment can not be prolonged, that is, it is either
 infinite, or ends with a state from which no further transition is possible.
 Initial fragment is defined as starting in 
\begin_inset ERT
status open

\begin_layout Plain Layout

$s 
\backslash
in I$
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
TODO
\end_layout

\begin_layout Standard
Program Graph, Non-determinism, Concurrency
\end_layout

\begin_layout Section
Linear Temporal Logic
\end_layout

\begin_layout Standard
Linear Temporal Logic (LTL) is an extension of propositional logic with
 two temporal modal operators.
 The notion of time within the context of LTL is not related to a ,,continuous
 real time line
\begin_inset Quotes erd
\end_inset

, but rather a discreet sequence of steps ordered by ,,precedence
\begin_inset Quotes erd
\end_inset

.
 This makes it ideal to reason about properties of TS executions, and indeed,
 it was first proposed specifically for the formal verification of computer
 programs [cit, wiki].
 Given an execution 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

, LTL formula 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F$
\end_layout

\end_inset

 assigns a boolean value to 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

.
 In other words, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

 satisfies 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F$
\end_layout

\end_inset

, expressed as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F 
\backslash
models 
\backslash
rho$
\end_layout

\end_inset

, iff 
\begin_inset ERT
status open

\begin_layout Plain Layout

$F$
\end_layout

\end_inset

 is evaluated as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$true$
\end_layout

\end_inset

 for 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rho$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Syntax of LTL can be inductively defined by extending propositional logic
 (PL) syntax.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Psi$
\end_layout

\end_inset

 are well-formed PL formulas, then:
\begin_inset Foot
status open

\begin_layout Plain Layout
Temporal operators have precedence and parentheses can be ommited if the
 result is not ambiguous.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Psi$
\end_layout

\end_inset

 are LTL formulas,
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$(
\backslash
mathbf{X}
\backslash
Phi)$
\end_layout

\end_inset

 is an LTL formula (pronounced ,,next 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

),
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

$(
\backslash
Phi
\backslash
mathbf{U}
\backslash
Psi)$
\end_layout

\end_inset

 is an LTL formula (,,
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Phi$
\end_layout

\end_inset

 until 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Psi$
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
The semantics can be informally descibed by providing executions that satisfy
 given formulas.
 We define 
\begin_inset ERT
status open

\begin_layout Plain Layout

$any$
\end_layout

\end_inset

 to be a placeholder for an arbitrary propositional formula:
\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$([
\backslash
Phi]_{0} 
\backslash
to [any]_{1} 
\backslash
to [any]_{2} 
\backslash
to [any]_{3} 
\backslash
to 
\backslash
dots) 
\backslash
models 
\backslash
Phi$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$([any]_{0} 
\backslash
to [
\backslash
Phi]_{1} 
\backslash
to [any]_{2} 
\backslash
to [any]_{3} 
\backslash
to 
\backslash
dots) 
\backslash
models 
\backslash
mathbf{X}
\backslash
Phi$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$([
\backslash
Phi
\backslash
land
\backslash
neg
\backslash
Psi]_{0} 
\backslash
to 
\backslash
dots 
\backslash
to [
\backslash
Phi
\backslash
land
\backslash
neg
\backslash
Psi]_{i} 
\backslash
to [
\backslash
Psi]_{i+1} 
\backslash
to [any]_{i+2} 
\backslash
to 
\backslash
dots) 
\backslash
models 
\backslash
Phi
\backslash
mathbf{U}
\backslash
Psi$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Moreover, we can use 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
mathbf{U}$
\end_layout

\end_inset

, to derive two additional important operators:
\end_layout

\begin_layout Itemize
,,Eventually
\begin_inset Quotes erd
\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Diamond
\backslash
Phi$
\end_layout

\end_inset

 which allows for expressing an assertion that must be true at some point
 in the future, defined as 
\begin_inset ERT
status open

\begin_layout Plain Layout

$true
\backslash
mathbf{U}
\backslash
Phi$
\end_layout

\end_inset

,
\end_layout

\begin_layout Itemize
,,always
\begin_inset Quotes erd
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Box
\backslash
Phi$
\end_layout

\end_inset

 for formulas that must be satisfied during the entire execution, equivalent
 to 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
neg
\backslash
Diamond
\backslash
neg
\backslash
Phi$
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
TODO bridge to TLA+
\end_layout

\begin_layout Section
Liveness and Fairness
\end_layout

\begin_layout Itemize
regular properties
\end_layout

\begin_layout Itemize
omega properties
\end_layout

\begin_layout Chapter
Distributed Hash Table
\begin_inset CommandInset label
LatexCommand label
name "chap:Distributed-hash-table"

\end_inset


\end_layout

\begin_layout Standard
Hash table is a data structure that maps keys to values (associative array),
 using a hashing function applied on keys.
 This is ordinarily used for a small sized in-memory data storage embedded
 inside a program.
 However, some use cases require storing of a large amount of unstructured
 data, which can use persistent key-value databases that store the data
 on hard drive storage.
 However, this reduces speed -> is not suitable for caching.
 To avoid the memory size limitation, data can be distributed across many
 nodes that together provide a large pool of fast (but volatile) memory.
\end_layout

\begin_layout Standard
The main issues arise from managing the distrubution of data on the nodes
 while maintaining high degree of consistency and availability.
\end_layout

\begin_layout Itemize
Formal definition, hash function
\end_layout

\begin_layout Section
Associative Array
\end_layout

\begin_layout Standard
Associative array (also dictionary or map) is an abstract data structure
 that can be represented as a relation between a set of keys and a set of
 values: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$R 
\backslash
subseteq K 
\backslash
times V$
\end_layout

\end_inset

, such that every key is mapped (in relation) to at most one value.
\end_layout

\begin_layout Standard
There are three basic operations defined for an associative array: 
\emph on
insert
\emph default
, 
\emph on
search
\emph default
 and 
\emph on
delete
\emph default
.
 [intro to alg.].
 Insert operation updates a dictionary instance to contain a key-value pair.
\begin_inset Foot
status open

\begin_layout Plain Layout
We are letting the failure handling to be implementation-specific.
\end_layout

\end_inset

 Search retrieves a value associated with a given key if it exists and delete
 removes the key-value pair from the dictionary.
\end_layout

\begin_layout Standard
The are many possible implementations of an associative array, but the most
 common are hash map and search tree.
 Typically, hash map is used due to the constant amortized cost for each
 operation, but search tree has better worst case performance (logarithmic
 vs.
 linear) and provides additional features, such as ordered iteration.
 [cit]
\end_layout

\begin_layout Standard
To illustrate the concept of dictionary, we will briefly describe a simple
 Direct-address table.
 [cit] Given 
\begin_inset ERT
status open

\begin_layout Plain Layout

$T$
\end_layout

\end_inset

 is a contiguous array of size 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|K|$
\end_layout

\end_inset

, let each position correspond to 
\begin_inset ERT
status open

\begin_layout Plain Layout

$k 
\backslash
in K$
\end_layout

\end_inset

.
 It is assumed that if 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K$
\end_layout

\end_inset

 is not of a form 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K' = 
\backslash
{ 0, 1, ..., |K| 
\backslash
}$
\end_layout

\end_inset

 there exists a bijective mapping function 
\begin_inset ERT
status open

\begin_layout Plain Layout

$m: K 
\backslash
to K'$
\end_layout

\end_inset

.
 If the table contains key 
\begin_inset ERT
status open

\begin_layout Plain Layout

$k$
\end_layout

\end_inset

, position 
\begin_inset ERT
status open

\begin_layout Plain Layout

$m(k)$
\end_layout

\end_inset

 holds a reference to the chosen value 
\begin_inset ERT
status open

\begin_layout Plain Layout

$v 
\backslash
in V$
\end_layout

\end_inset

, otherwise there is a special 
\begin_inset ERT
status open

\begin_layout Plain Layout

$nil$
\end_layout

\end_inset

 value.
\end_layout

\begin_layout Standard
This implementation is practical only if 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K$
\end_layout

\end_inset

 is reasonably small, or most of the keys are in use.
 The dictionary operations would then reduce to those of the contiguous
 array, e.g 
\begin_inset ERT
status open

\begin_layout Plain Layout

$Insert(T, k, v) 
\backslash
stackrel{
\backslash
Delta}{=} T[k] := v$
\end_layout

\end_inset


\end_layout

\begin_layout Section
Hash Table
\end_layout

\begin_layout Standard
The problems of the Direct-address table can be resolved by reducing the
 contiguous array to a reasonable size.
 This would result in some 
\begin_inset ERT
status open

\begin_layout Plain Layout

$k$
\end_layout

\end_inset

 not having an assigned slot, however we can replace 
\begin_inset ERT
status open

\begin_layout Plain Layout

$m$
\end_layout

\end_inset

 with a surjective 
\emph on
hash
\emph default
 function 
\begin_inset ERT
status open

\begin_layout Plain Layout

$h$
\end_layout

\end_inset

 that maps the set of keys to a smaller set 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K'$
\end_layout

\end_inset

 of indices into 
\begin_inset ERT
status open

\begin_layout Plain Layout

$T$
\end_layout

\end_inset

.
 This would require that more than one value may be stored in a single position
 (a 
\emph on
collision
\emph default
), but the slot can be used to reference a linked list that will contain
 the overflowing key-value pairs.
 This would increase the 
\emph on
worst-case
\emph default
 complexity of 
\emph on
search
\emph default
 operation to 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
O (n)$
\end_layout

\end_inset

, but the 
\emph on
amortized
\emph default
 cost remains 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
O (1)$
\end_layout

\end_inset

, if the hash function is properly chosen.
 [cit]
\end_layout

\begin_layout Standard
,,A good hash function satisfies (approximately) the assumption of simple
 uniform hashing: each key is equally likely to hash to any of the [...] slots,
 independently of where any other key has hashed to.
\begin_inset Quotes erd
\end_inset

 [cit, intro to alg]
\end_layout

\begin_layout Standard
One of the commonly used hash functions is 
\emph on
division remainder
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$h(k) = k mod z$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset ERT
status open

\begin_layout Plain Layout

$z$
\end_layout

\end_inset

 should be a prime number not close to some power of 2.
 [TODO]
\end_layout

\begin_layout Standard
Although this method reduces the wasting of space when compared to the Direct-ad
dress table, in some cases the size of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$V$
\end_layout

\end_inset

 is too large for a physical memory of a single computer.
 However, because of the advantagions properties of hash functions, it is
 feasible to split the table into several chunks and distribute it across
 nodes in a distributed system.
 [reword]
\end_layout

\begin_layout Section
Parallelism and Concurrency
\end_layout

\begin_layout Standard
In the previous section, we have descibed a use case where it is advantageous
 to use multiple physical machines (processors) to deal with resource-intensive
 tasks.
 Parallelization has become the only major way to keep increasing the processing
 power of modern computers sufficiently to meet the demand, apart from increasin
g transistor density.
\begin_inset Foot
status open

\begin_layout Plain Layout
Not considering alternative models of computations, in particular the quantum
 computing, which is not yet practical to be in common use.
\end_layout

\end_inset

 This includes scaling-up, by adding multiple processing units into a single
 CPU, and scaling out by using multiple physical computers connected by
 a network.
 Creating algorithms that can safely work in a parallell environment has
 therefore become one of the most important tasks of software design.
\end_layout

\begin_layout Standard
[TODO]
\end_layout

\begin_layout Section
Distributed Algorithm
\end_layout

\begin_layout Standard
TODO common problems and algorithms
\end_layout

\begin_layout Itemize
Coordinator selection
\end_layout

\begin_layout Itemize
Distributed locking
\end_layout

\begin_layout Section
CAP theorem
\end_layout

\begin_layout Standard
it is impossible for a distributed computer system to simultaneously provide
 all three of the following guarantees:
\end_layout

\begin_layout Itemize
Consistency (all nodes see the same data at the same time)
\end_layout

\begin_layout Itemize
Availability (every request receives a response about whether it succeeded
 or failed) 
\end_layout

\begin_layout Itemize
Partition tolerance (the system continues to operate despite arbitrary partition
ing due to network failures) 
\end_layout

\begin_layout Section
Algorithms
\end_layout

\begin_layout Standard
TODO
\end_layout

\begin_layout Section
Consistent Hashing
\end_layout

\begin_layout Standard
In the section describing a hash table, an idea of partitioning and distributing
 the data onto multiple separate nodes was proposed.
 To ensure effective read/write operations, all nodes must be aware of where
 value corresponding to each key should be stored, otherwise they would
 have to broadcast read requests or cause fragmentation when choosing where
 to write at random.
 Moreover, this mapping cannot be stored individually for each key or the
 space needed to store the keys would be linearly dependent on the number
 of values and defeating the point of distributed storage.
 Therefore, given that the image 
\begin_inset ERT
status open

\begin_layout Plain Layout

$K'$
\end_layout

\end_inset

 of the hashing function 
\begin_inset ERT
status open

\begin_layout Plain Layout

$h$
\end_layout

\end_inset

 is a set of integers in the form 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
{0, 1, ..., |K|
\backslash
}$
\end_layout

\end_inset

 , it is necessary to store that assignment as a set of ranges of keys 
\begin_inset ERT
status open

\begin_layout Plain Layout

$R$
\end_layout

\end_inset

, where each element is in the form 
\begin_inset ERT
status open

\begin_layout Plain Layout

$r_{<i, j>} = 
\backslash
{i, (i + 1), (i + 2), ..., j
\backslash
}$
\end_layout

\end_inset

 and all keys are covered: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
forall k 
\backslash
in K, 
\backslash
exists r 
\backslash
in R: k 
\backslash
in r$
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The mapping 
\begin_inset ERT
status open

\begin_layout Plain Layout

$p: N 
\backslash
to R$
\end_layout

\end_inset

 from the set of nodes 
\begin_inset ERT
status open

\begin_layout Plain Layout

$N$
\end_layout

\end_inset

 to the key-ranges (and reverse) may be created in numerous ways.
 There are two main properties that affect a choice of 
\begin_inset ERT
status open

\begin_layout Plain Layout

$p$
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize

\emph on
Load factors
\emph default
 that determines a percentage of keys that are assigned for each individual
 node, usually to reflect the amount of computing resources available to
 store the values on a node, and
\end_layout

\begin_layout Itemize

\emph on
replication parameter
\emph default
, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$1 
\backslash
geq rp 
\backslash
geq |N|$
\end_layout

\end_inset

, that specifies the number of nodes that each key is assigned to.
\end_layout

\begin_layout Standard
Some of the implementations of DHTs allow for setting more complex load
 factors setting, but for the our purposes, we will use a weak requirement
 to balance data equally among the nodes.
 Replication parameter reflects a tradeoff between the extra storage space
 and higher write speed available with lower values and resiliency and improved
 read speed with higher values.
 Additional requirement for a good algorithm for computing 
\begin_inset ERT
status open

\begin_layout Plain Layout

$p$
\end_layout

\end_inset

 in the presence of unreliable environment is that in the event of node
 failure, it minimizes the number of keys, and with them the amount of data,
 that must be relocated to other nodes, called 
\emph on
rebalancing
\emph default
.
 Techniques that respect the described requirements are called 
\emph on
consistent hashing
\emph default
 and one of the most used, elegant, and simple concepts used to implement
 it is 
\emph on
hash wheel
\emph default
.
\end_layout

\begin_layout Section
Leader Election
\end_layout

\begin_layout Standard
[TODO]
\end_layout

\begin_layout Chapter
Infinispan
\end_layout

\begin_layout Standard
,,Infinispan is a distributed in-memory key/value data store [...].
 It can be used both as an embedded Java library and as a language-independent
 service accessed remotely over a variety of protocols [...].
 It offers advanced functionality such as transactions, events, querying
 and distributed processing.
\begin_inset Quotes erd
\end_inset

 [cit, inf.
 web page] Provided to customers by Red Hat as JBoss Data Grid, it is a
 solution ,,to store information for very fast, low-latency response time
 and very high throughput
\begin_inset Quotes erd
\end_inset

.
 [jdg page] It can be used as a ,,distributed cache, NoSQL database, and
 event broker
\begin_inset Quotes erd
\end_inset

 [jdg page] to improve data storage and processing capabilities of massive-scale
 applications.
 Most of these featues are built on top of a modern distributed hash table
 implementation, therefore, for the purpose of this work, it is a great
 model example to explore.
 As a result, this chapter focuses on analyzing the core parts of this project.
\end_layout

\begin_layout Section
Infinispan as a Cache
\end_layout

\begin_layout Standard
Cache is a data structure, which is used to temporarily store information
 that would be more expensive to compute or retrieve separately and repeatedly
 for each request.
 The most basic cache implementations provide the same interface as an associati
ve array.
 There are three main caching techniques that can be used: [cit computerweekly.co
m]
\end_layout

\begin_layout Itemize

\emph on
Write-through
\emph default
 cache directs expensive write operation onto cache and through to underlying
 permanent storage before confirming completion to the host,
\end_layout

\begin_layout Itemize

\emph on
write-around
\emph default
 cache is similar, but data is written directly to permanent storage, and
 are cached upon subsequent reading, and
\end_layout

\begin_layout Itemize

\emph on
write-back 
\emph default
cache where the information being written is directed to cache and completion
 is immediately confirmed to the host and synchronized to the backing storage
 later.
\end_layout

\begin_layout Standard
Infinispan supports all of these techniques.
 [cit inf.
 docs]
\end_layout

\begin_layout Section
Clustering in Infinispan
\end_layout

\begin_layout Standard
Infinispan offers four modes of operation, which determine how and where
 the data is stored: 
\end_layout

\begin_layout Itemize

\emph on
Local,
\emph default
 where entries are stored on the local node only, regardless of whether
 a cluster has formed,
\end_layout

\begin_layout Itemize

\emph on
invalidation,
\emph default
 a write-around mode, where all entries are stored in a permanent store
 and cache is used to alleviate intensive read operations.
 Clustering is used only to invalidate data on all nodes on change.
 
\end_layout

\begin_layout Itemize

\emph on
Replication,
\emph default
 where all entries are replicated to all nodes.
 In this mode, Infinispan doesn’t offer an increased space but a faster
 read times.
 
\end_layout

\begin_layout Itemize

\emph on
Distribution
\emph default
, in which case entries are distributed to a subset of the nodes only.
 This option provides increased heap space by distributing the data on multiple,
 but not all nodes.
 Uses topology aware consistent hashing to offer improved durability in
 case of node crashes or network outages.
\end_layout

\begin_layout Standard
Last three options can use synchronous or asynchronous modes.
 In synchronous mode (write-through), client waits until the operations
 are confirmed complete, asynchronous (write-back) offers the fastest non-blocki
ng access.
\end_layout

\begin_layout Section
Distributed mode
\end_layout

\begin_layout Standard
Every entry is stored on a subset of the nodes in the grid, providing increased
 storage capacity for increased latency.
\end_layout

\begin_layout Standard
Compared to replication, distribution offers increased storage capacity,
 but with increased latency to access data from non-owner nodes, and durability
 (data may be lost if all the owners are stopped in a short time interval).
 Adjusting the number of owners allows you to obtain the trade off between
 space, durability, and latency.
\end_layout

\begin_layout Standard
Infinispan also offers a topology aware consistent hash which will ensure
 that the owners of entries are located in different data centers, racks,
 or physical machines, to offer improved durability in case of node crashes
 or network outages.
 The cache should be configured to work in distributed mode (either synchronous
 or asynchronous), and can otherwise be configured as normal.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename infinispn-distributed-mode.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
CAP theorem - Infinispan has traditionally been biased towards Consistency
 and Availability, sacrificing Partition-tolerance.
\end_layout

\begin_layout Standard
A service that is consistent operates fully or not at all.
 Gilbert and Lynch use the word “atomic” instead of consistent in their
 proof, which makes more sense technically.
\end_layout

\begin_layout Section
Architecture
\end_layout

\begin_layout Standard
Core infinispan functionality is implemented in several components:
\end_layout

\begin_layout Itemize
JGroups transport layer used to form the cluster reliable communications
 between members provides information about topology change
\end_layout

\begin_layout Itemize
RPC framework on top of the transport layers each action is modeled as a
 separate 
\emph on
command object
\emph default
, that is replicated and transported to the target cluster members, encapsulates
 cahce operations
\end_layout

\begin_layout Itemize
DataContainer The main internal data structure which stores entries
\end_layout

\begin_layout Itemize
LockManager An interface to deal with all aspects of acquiring and releasing
 locks for cache entries.
\end_layout

\begin_layout Standard
IoC container that stores many other components CommandsFactory EvictionManager
 ExpirationManager InterceptorChain TransactionManager RpcManager LockManager
 PartitionHandlingManager etc.
 
\end_layout

\begin_layout Section
JGroups
\end_layout

\begin_layout Standard
Java library for reliable clustering.
 It is used by Infinispan as the transport layer.
 It consists of:
\end_layout

\begin_layout Itemize
abstract channels (JChannel) 
\end_layout

\begin_layout Itemize
stack of protocols (up, down), on the lowest level are TCP or UDP sockets
\end_layout

\begin_layout Standard
Protocols 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
http://www.jgroups.org/manual/html/protlist.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
transport - UDP, TCP
\end_layout

\begin_layout Itemize
discovery PING, TCPPING, MPING
\end_layout

\begin_layout Itemize
merging finds nodes merge node leaves cluster & then joins again (MERGE3)
 
\end_layout

\begin_layout Itemize
failure detection FD_ALL multicast heartbeat FD_SOCK
\end_layout

\begin_layout Itemize
reliable transmission ordering NAKACK, UNICAST3 
\end_layout

\begin_layout Itemize
message stability STABLE 
\end_layout

\begin_layout Itemize
group members GMS - leaves, joins 
\end_layout

\begin_layout Itemize
flow control UFC, slowing down 
\end_layout

\begin_layout Itemize
fragmentation FRAG2, split & reassebles large msgs synchronous sending RSVP
 state transfer STATE_TRANSFER, STATE
\end_layout

\begin_layout Standard
API overview
\end_layout

\begin_layout Itemize
Group - A group is identified by its name.
 Groups do not have to be created explicitly; when a process joins a non-existin
g group, that group will be created automatically.
 Processes of a group can be located on the same host, within the same LAN,
 or across a WAN.
 A member can be part of multiple groups.
\end_layout

\begin_layout Itemize
Adress - class uniquely identifying a node
\end_layout

\begin_layout Itemize
JChannel - This is the core interface of JGroups.
 Requires stack configuration (e.g.
 using an xml file).
 Connect method takes group name (uses UDP multicast for discovery) or adress
 of an existing member.
 Send method requires an adress (from view) to unicast, multicast does not.
\end_layout

\begin_layout Itemize
View - nodes receive view objects containing a snapshot of the current list
 of nodes, changes each time a node joins or leaves the cluster.
 First node in the list is the coordinator.
 
\end_layout

\begin_layout Itemize
Operations connect to cluster send message receive message
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO, config xml for Infinispan, org.infinispan.remoting.transport.jgroups
\end_layout

\end_inset


\end_layout

\begin_layout Section
Remoting
\end_layout

\begin_layout Paragraph*
ReplicationQueue
\end_layout

\begin_layout Standard
Periodically (or when certain size is exceeded) takes elements and replicates
 them.
 Queue of Replicable Command objects, the core of the command-based cache
 framework.
 Commands correspond to specific areas of functionality in the cache.
\end_layout

\begin_layout Paragraph*
Transport
\end_layout

\begin_layout Standard
An interface that provides a communication link with remote caches.
 Also allows remote caches to invoke commands on this cache instance.
 Has a number of invokeRemotely* methods, sync and async, that invoke an
 RPC call on other caches in the cluster.
 Returns a map of responses from each member contacted.
 Uses a Total Order protocol.
 Remembers if this cache is a coordinator, current adress, adresses of members
 in the cluster view.
 It is implemented as JGroupsTransport, which uses JGroups to transmit command
 objects to the other nodes.
\end_layout

\begin_layout Section
Commands
\end_layout

\begin_layout Standard
All cache operations are represented as command objects, both locally and
 as a form of RPC can be sent to other nodes in the cluster.
 ReplicableCommand is the core interface of the command-based cache framework.
 Commands correspond to specific areas of functionality in the cache, and
 can be replicated using the org.infinispan.remoting.rpc.
 RpcManager.
 Main method is 
\emph on
Object perform(InvocationContext ctx) throws Throwable
\emph default
, which performs the primary function of the command.
 Infinispan uses visitor (interceptor) pattern, to handle the command in
 several steps.
 This method will be invoked at the end of interceptors chain.
 Every command has an unique ID that identifies it when serialized to be
 sent via the network.
\end_layout

\begin_layout Chapter
Model checking tools (techniques?)
\end_layout

\begin_layout Standard
There are several types of techniques for model checking and tools that
 implement each approach.
 After considering the available options, one is chosen for the final implementa
tion.
\end_layout

\begin_layout Section
Model checking techniques
\end_layout

\begin_layout Itemize
Explicit-state Model Checking - TLC (TLA+/PlusCal), SPIN (Promela - Process/Prot
ocol Meta Language)
\end_layout

\begin_layout Itemize
Symbolic Execution - Java Path Finder (Java/bytecode) http://babelfish.arc.nasa.gov
/trac/jpf
\end_layout

\begin_layout Itemize
JPF Implementation of the JVM, executes the bytecode directly.
\end_layout

\begin_layout Itemize
SPIN Processes that communicate via channels (message passing)
\end_layout

\begin_layout Chapter
TLA+
\end_layout

\begin_layout Standard
In this chapter TLA+ is introduced.
\end_layout

\begin_layout Section
Basic Mathematics
\end_layout

\begin_layout Standard
TLA stands for the Temporal Logic of Actions, but it has become a shorthand
 for referring to the TLA+ specification language and the PlusCal algorithm
 language, together with their associated tools.
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO reword
\end_layout

\end_inset

 TLA+ is especially well suited for writing high-level specifications of
 concurrent and distributed systems.
 [cit, web].
 
\end_layout

\begin_layout Standard
TLA system (TLAS) is complex, so only selected parts are described.
\begin_inset Foot
status open

\begin_layout Plain Layout
TODO explain
\end_layout

\end_inset

 but the main idea is to enable users to express mathematical formulas using
 a clean and human-readable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

-like syntax.
 TLA+ is based on the idea that the best way to describe things formally
 is with simple mathematics, and that a specification language should contain
 as little as possible beyond what is needed to write simple mathematics
 precisely.
 [cit] The are several built-in mathematical operators for expressing:
\end_layout

\begin_layout Itemize
Equality,
\end_layout

\begin_layout Itemize
Set Theory (Zermelo–Fraenkel [cit]) operations,
\end_layout

\begin_layout Itemize
Propositional, Predicate and LTL logic theorems.
\end_layout

\begin_layout Standard
With a definition operator, user can provide additional mathematical objects
 and operations.
 The basic TLA does not contain arithmetic operations on natural numbers,
 for example, and their definitions must be imported from a standard module
 library.
 Every data structure is 
\emph on
conceptually
\begin_inset Foot
status open

\begin_layout Plain Layout
For performace reasons, this may not be true for an actual implementation
 of TLAS.
 
\end_layout

\end_inset


\emph default
 a set.
 This includes natural numbers, that are defined using Peano axioms.
 The library modules include: Bags, FiniteSets, Integers, Naturals, Peano,
 ProtoReals, Reals, and Sequences.
 
\end_layout

\begin_layout Section
Specifications
\end_layout

\begin_layout Standard
Model specification is in the TLA system defined using a single temporal
 formula, most commonly
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$Spec 
\backslash
stackrel{
\backslash
Delta}{=} Init 
\backslash
land 
\backslash
Box[Next]_{
\backslash
langle vars 
\backslash
rangle}$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
written as:
\begin_inset Foot
status open

\begin_layout Plain Layout
In subsequent text, monospace font is used to display related source code.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb$Spec == Init /
\backslash
 [][Next]_<<vars>>$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This formula must hold for all executions, therefore specifying exactly
 that transition system from an abstract space of all possible systems that
 represents the model.
 The 
\emph on
Init
\emph default
 formula establishes a set of initial states and the 
\emph on
Next
\emph default
 must be true for all subsequent states.
 However, if this was an ordinary LTL formula, it would not be possible
 to describe how ,,information
\begin_inset Quotes erd
\end_inset

 can change between subsequent states.
 To solve this problem, TLA extends LTL by allowing to reference not only
 variables present in the current state, but also the variables in the next
 state.
 This is done by ,,priming
\begin_inset Quotes erd
\end_inset

 the variable name.
 For instance, if we define:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$Init 
\backslash
stackrel{
\backslash
Delta}{=} x = 0$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout

$Next 
\backslash
stackrel{
\backslash
Delta}{=} x' = x + 1$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
we are specifying a variable that must be incremented during each step.
\end_layout

\begin_layout Chapter
PlusCal
\end_layout

\begin_layout Standard
PlusCal is an algorithm language that can be translated into an expression
 in TLA+.
 The purpose of PlusCal is to make writing of specifications easier, since
 it is often simpler to express an algorithm in an imperative way using
 a C-like or Pascal-like syntax.
 This chapter provides an overview of the language as well as an explanation
 of the ideas behind the translation process.
\end_layout

\begin_layout Section
Control Flow Graph
\end_layout

\begin_layout Standard
The main idea behind PlusCal is to convert a collection of atomic algorithmic
 steps, usually variable assignments, and control flow statements, most
 importantly the conditional 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{if}
\end_layout

\end_inset

 and unconditional 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{goto}
\end_layout

\end_inset

 jump into an abstract control flow graph.
 
\end_layout

\begin_layout Standard
Control flow graph (CFG) is a representation, using graph notation, of all
 paths that might be traversed through a program during its execution.
 [cit, wiki].
 Nodes in CFG represent a block of code that is executed sequentially, and
 directed edges represent possible control flow changes.
 Node should contain at most one logical control flow statement, e.g 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{for(...)}
\end_layout

\end_inset

.
 Edge starts in a node with such a statement, and ends with a node containing
 a possible jump target.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
PlusCal algorithm for hour clock
\begin_inset CommandInset label
LatexCommand label
name "fig:1"

\end_inset


\end_layout

\end_inset


\begin_inset Graphics
	filename hr-clock-pc.png
	width 15cm
	BoundingBox 0cm 0bp 1266bp 660bp

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:1"

\end_inset

, a PlusCal algorithm for the hour clock problem described previously [TODO
 ref chapter] is presented.
 Note that it starts with a declaration of global variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{hr}
\end_layout

\end_inset

, and contains two control flow statemens (infinite 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{for}
\end_layout

\end_inset

 loop and an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{if}
\end_layout

\end_inset

 conditional) and two assignments.
 In addition, the algorithm contains labels (such as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{s01:}
\end_layout

\end_inset

 to mark ,,atomic
\begin_inset Quotes erd
\end_inset

 statements, that represent a single step in the resulting TLA+ execution.
 As a result, there must be at most one assignment to the same variable
 per label.
 In addition, they are also used to designate nodes in the CFG, and therefore
 are required at places where the control flow changes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Program Graph for hour clock algorithm
\begin_inset CommandInset label
LatexCommand label
name "fig:Program-Graph-for"

\end_inset


\end_layout

\end_inset


\begin_inset Graphics
	filename prog-graph.png
	width 10cm

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The final graph, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Program-Graph-for"

\end_inset

 contains five nodes (there is always a special 
\emph on
Init
\emph default
 node) and 6 edges.
 Each of these nodes is translated into a separate TLA+ definition.
 To determine which path in the algorithm is taken, an additional 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{pc}
\end_layout

\end_inset

 variable (program counter) is defined for each process (PlusCal can be
 used to define multiple concurrently executed processes) and works like
 a instruction pointer register in common processors.
 Each TLA+ node-definition contains a condition, that requires the program
 counter value to contain a name of the label it implements.
 Moreover, it sets the counter value to enable transition to one of the
 subsequent nodes in CFG.
 As a result, the final TLA+ 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{Next}
\end_layout

\end_inset

 formula is a conjunction of statements for each label, as prezented in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Translated-PlusCal-algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Translated PlusCal algorithm for hour clock
\begin_inset CommandInset label
LatexCommand label
name "fig:Translated-PlusCal-algorithm"

\end_inset


\end_layout

\end_inset


\begin_inset Graphics
	filename hr-clock-pc-translation.png
	width 10cm

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Readers-Writers Problem
\end_layout

\begin_layout Standard
Readers-writers is a classical ,,problem of the mutual exclusion of several
 independent processes from simultaneous access to a 
\emph on
critical section
\emph default
.
 [...] There are two distinct classes of processes known as 
\emph on
readers
\emph default
 and 
\emph on
writers
\emph default
.
 The readers may share the section with each other, but the writers must
 have exclusive access.
\begin_inset Quotes erd
\end_inset

 [Curtois] Therefore, the critical section contains read or write operations
 on a shared variable performed by readers and writers, respectively.
 There may be additional liveness and fairness constrains, resulting in
 several possible solutions.
 
\end_layout

\begin_layout Itemize
[wiki -> Courtois et al.]
\end_layout

\begin_layout Itemize
first readers-writers problem, in which the constraint is added that no
 reader shall be kept waiting if the share is currently opened for reading.
 This is also called readers-preference
\end_layout

\begin_layout Itemize
This is the motivation for the second readers-writers problem, in which
 the constraint is added that no writer, once added to the queue, shall
 be kept waiting longer than absolutely necessary.
 This is also called writers-preference.
\end_layout

\begin_layout Itemize
Therefore, the third readers-writers problem is sometimes proposed, which
 adds the constraint that no thread shall be allowed to starve; that is,
 the operation of obtaining a lock on the shared data will always terminate
 in a bounded amount of time.
\end_layout

\begin_layout Standard
Readers-preference
\end_layout

\begin_layout Section
Dining Philosophers
\end_layout

\begin_layout Standard
TODO 
\end_layout

\begin_layout Itemize
Demonstrate deadlock detection
\end_layout

\begin_layout Chapter
[Infinity DHT] Model Design
\end_layout

\begin_layout Standard
In this chapter, top-down desing of the model is presented.
\end_layout

\begin_layout Section
High-level design
\end_layout

\begin_layout Standard
TODO this is no longer vaid
\end_layout

\begin_layout Standard
System is an interaction between a cluster of data (server) nodes a set
 of clients issuing read and write requests to each data node.
 More formally, system is modeled as a 4-tuple Q=(C, S, N, M) where
\end_layout

\begin_layout Itemize
C is a set of client nodes
\end_layout

\begin_layout Itemize
S is a set of server nodes
\end_layout

\begin_layout Itemize
N is the network which handles the communication
\end_layout

\begin_layout Itemize
M is the set of possible messages that can be transported over the network
\end_layout

\begin_layout Standard
Let X be some well-defined component of the sytem.
 states(X) be a set of all possible states that X can be in.
 Because the entire system must be a finite-state machine with a reasonable
 size, we must have a mechanism to estimate the state space size.
 We can encode each state in a unique a bit-string of length log2(|M|).
 Because the model represents a storage system, it is not possible to model
 data table with a reasonable capacity and bounds.
 Therefore the parameters that influence |states(Q)| must be carefuly selected.
 This includes the size of the separate components of Q, such as the number
 of nodes.
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO expand
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We will now explore components M of the system in increasingly more detail,
 select parameters that which we want to include in the model and estimate
 their effect on |states(Q)|.
\end_layout

\begin_layout Section
Network
\end_layout

\begin_layout Standard
What type of network is it useful to simulate? -> connectionless datagram
 network like UDP, not TCP (although that is available for infinispan)
\end_layout

\begin_layout Section
Network Reliability
\end_layout

\begin_layout Standard
Communication over a network should be as reliable as possible.
 In a perfect world, nodes in a distributed system should always succeed
 in sending messages to others and in receiving them back.
 In reality however, communication protocols must deal with messages arriving
 late, in a different order than they were sent, or not at all.
 When designing and specifying such protocols, it is important to consider
 which failure modes the networking part of the model should simulate, especiall
y when keeping the number of its states as small as possible is a necessity.
 On the other hand, to be useful, the model must be verified under failure
 conditions that occur in the real world.
\end_layout

\begin_layout Itemize
The network model simulates 
\emph on
message order change
\emph default
, but not 
\emph on
latency
\emph default
.
 
\begin_inset Newline newline
\end_inset

This means, that if some message has been sent to a node, it shall not receive
 a ,,no message available
\begin_inset Quotes erd
\end_inset

 signal.
 However, if there is more that one packet ,,in the network
\begin_inset Quotes erd
\end_inset

, any of them may be delivered first.
\end_layout

\begin_layout Itemize
It is necessary to simulate network partition and recovery, but random packet
 loss is not simulated.
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
This may be included after all.
\end_layout

\end_inset

 This means that network connection between nodes may be lost only in a
 specific points in the model execution.
 TODO explain, Two Generals problem, TCP/IP in real world?
\end_layout

\begin_layout Itemize

\emph on
Double delivery
\emph default
 is not simulated.
 This increases model complexity and can be avoided in implementation, by
 using suficiently large monotonic sequence to mark packets.
\end_layout

\begin_layout Itemize
Undelivered packets are removed on connection loss.
 
\end_layout

\begin_layout Section
Message Model
\end_layout

\begin_layout Standard
Message structure is inspided by UDP/IP packets.
 Each message contains three fields: recipient, sender and data.
 The data type is therefore 
\begin_inset ERT
status open

\begin_layout Plain Layout

$msg 
\backslash
in (AddressSpace 
\backslash
times AddressSpace 
\backslash
times DataSpace)$
\end_layout

\end_inset

.
 There is a special singleton 
\begin_inset ERT
status open

\begin_layout Plain Layout

$NoMessage$
\end_layout

\end_inset

 message for signalling that the network has no packets available for the
 requester.
 This includes a case of network failure.
 Because TLA requires sets to be enumerable, it is important to estimate
 numer of possible messages: 
\begin_inset ERT
status open

\begin_layout Plain Layout

$|AddressSpace|^2 
\backslash
dot |DataSpace|$
\end_layout

\end_inset

.
 If we need 3 nodes and one unclaimed address to model simplest DHT system,
 and consider read and write operations for 12 possible keys and 2 possible
 valuest, the lower bound is 4^2 * 2 * 12 * 2 = 768 messages.
 The content of the network may be up to 2^768.
 We will have to make sure this will we far less in reality.
 Eg.
 cluster-wide write locking (max NodeCount write messages), discovery-protocol-l
ocking, artificial packet cap (max number of ,,in network
\begin_inset Quotes erd
\end_inset

 messages for each connection, e.g.
 3: 3 * N * (N-1) = 3 * 4 * 3 = 36, i.e (768 choose 36) + (768 choose 35)
 + ...
 + 1 =~ 9.17*10^61?
\end_layout

\begin_layout Section
Network Model
\end_layout

\begin_layout Standard
From an highly abstract (not a good term) point of view, computer network
 is an undirected graph, with nodes representing addressable elements and
 edges connections between them.
 Since the network has not only a topology, but also a state, each .
\end_layout

\begin_layout Standard
Constructing simplified model is necessary.
 First, topology - it is unnecessary to consider internal structure of the
 network, including routing elements.
 It can be simplified into a subgraph of a connected graph.
 Additionaly, if there is a path from A to C via B, it is good to assume
 that A to C is also connected.
 Algorithm for relay can be easily implemented, and there is no reason to
 not use it in a general case.
 Therefore, each connected component becomes a complete graph.
 This information can be more effectively stored as a set of network partitions,
 each partition is a set containing nodes, where a single node must be in
 exactly one partition.
 If we remove a need for routing (better to say forwarding) nodes, network
 state may be simplified to a list of messages that are being tranfered
 via each connection.
 However, it would be overkill to assign a buffer to each connection, since
 the messages already contain receiver and sender addresses, and therefore
 all messages may be stored in the same buffer for the entire partition.
 However even more simply, since we already have the information whether
 sender and receiver are in the same partition, we can actually store all
 messages that are waiting to be received in a single set for the entire
 network.
 We can therefore check if the message is stored in the buffer or thrown
 away.
 To keep the buffer smallest possible, if a partition happens, throw away
 now undeliverable messages.
\end_layout

\begin_layout Standard
Does this conform to the previously stated failure constraints?
\end_layout

\begin_layout Standard
Therefore: (copy paste parts of network spec)
\end_layout

\begin_layout Standard
,,Operations
\begin_inset Quotes erd
\end_inset

 (TODO define as special predicates):
\end_layout

\begin_layout Itemize
send (packet/data)
\end_layout

\begin_layout Itemize
receive
\end_layout

\begin_layout Itemize
internal clean
\end_layout

\begin_layout Itemize
do_partition() // args?, original, new one?
\end_layout

\begin_layout Itemize
do_nondet_partition
\end_layout

\begin_layout Itemize
do_mend + nondet
\end_layout

\begin_layout Itemize
broadcast // should be modeled 
\end_layout

\begin_layout Standard
Space size estimation -> limit this, (some states may not even be reachable,
 or make sure they are not)
\end_layout

\begin_layout Standard
What to do if network capacity reached? -> throw away (can we do that?)
\end_layout

\begin_layout Section
Node
\end_layout

\begin_layout Standard
TODO how node is structured, overview
\end_layout

\begin_layout Section
View Distribution Protocol (Leader Election)
\end_layout

\begin_layout Section
Distributed Read Protocol
\end_layout

\begin_layout Standard
See readers-writers problem
\end_layout

\begin_layout Section
Distributed Write Protocol
\end_layout

\begin_layout Standard
see readers-writers problem
\end_layout

\begin_layout Section
Distributed Read and Write
\end_layout

\begin_layout Standard
In one of the previous chapters, we have described a solution to the problem
 of ensuring that concurrent read and write access to the shared variableconsist
ent
\end_layout

\begin_layout Section
Paxos
\end_layout

\begin_layout Standard
Paxos is a family of algorithms for reaching consensus in a distributed
 system operating in an unreliable environment.
 Given a set of nodes (processes), a consensus algorithm ensures that a
 single one among the proposed values is chosen.
 [paxos made simple] The safety requirements for consensus are:
\end_layout

\begin_layout Itemize
Only a value that has been proposed may be chosen,
\end_layout

\begin_layout Itemize
only a single value is chosen, and 
\end_layout

\begin_layout Itemize
a process never learns that a value has been chosen unless it actually has
 been.
 [cit]
\end_layout

\begin_layout Standard
To describe the algorithm, three roles are used: proposer, acceptor, and
 learner.
 In many versions of Paxos, nodes asume more than one role.
 For the purposes of DHT design, where the nodes are equal and run the same
 software, this results in all nodes having each role.
 There are following assumptions about unreliability of nodes and the network:
\end_layout

\begin_layout Itemize
Each node runs asynchronously at different speeds and may stop or restart.
\end_layout

\begin_layout Itemize
Messages may be delayed, lost or reordered, but there are no Byzantine errors
 (they may not be corrupted).
\end_layout

\begin_layout Standard
The central idea of the Paxos is to extend three-phase-commit protocol (3PC)
 with the concept of quorums.
 
\end_layout

\begin_layout Standard
A single round of 3PC consists of three phases, with participating nodes
 having two possible roles, 
\emph on
coordinator
\emph default
 or 
\emph on
agent
\emph default
.
 Coordinator is the initiator and manager of the transaction, while agents
 can vote to 
\emph on
accept
\emph default
 the transaction and 
\emph on
learn
\emph default
 about the results.
\end_layout

\begin_layout Standard
In the first phase, coordinator receives a request to initiate a transaction,
 and sends <prepare> messages to all agents, containing the transaction
 information and waits for the resposes, or aborts on time-out.
 Agents receive the message, and decide whether they are ready for the transacti
on to start, and send <accept> or <reject>
\end_layout

\begin_layout Standard
Quorum is a subset of acceptors, large enough that any such subset must
 have at least one acceptor in common with the choice in the previous round.
 This ensures that there is always some acceptor that has learnt the newest
 value and can rejects an invalid proposal.
\end_layout

\begin_layout Standard
[--]
\end_layout

\begin_layout Standard
Second, getting a consensus protocol right is hard.
 Simple solutions don’t work very well, exhibiting undesirable behaviours
 and occasionally acting incorrectly.
 Mike Burrows, inventor of the Chubby service at Google, says that “there
 is only one consensus protocol, and that’s Paxos” – all other approaches
 are just broken versions of Paxos.
\end_layout

\begin_layout Chapter
Execution and Analysis
\end_layout

\begin_layout Standard
TODO:
\end_layout

\begin_layout Itemize
Verification of standalone modules
\end_layout

\begin_layout Itemize
Limitations on state space
\end_layout

\begin_layout Itemize
Test on Amazon AWS, x1.16xlarge 64vcpu 976gbram 1 x 1920gb SSD, $6.669 per
 Hour = 168.16czk
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

BAIER Christel, KATOEN Joost-Pieter.
 Principles of Model Checking, Cambridge, Massachusetts: The MIT Press,
 ISBN 978-0-262-02649-9.
\end_layout

\begin_layout Chapter*
Appendix A
\begin_inset Newline newline
\end_inset

Archive Content
\begin_inset CommandInset label
LatexCommand label
name "chap:Appendix-AArchive-Content"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{chapter}{
\backslash
textbf{A
\backslash
hspace{.75em}Archive Content}}
\end_layout

\end_inset

This archive contains contents of the project's git repository, currently
 hosted on GitHub:
\end_layout

\begin_layout Itemize
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename foo.png

\end_inset


\end_layout

\end_body
\end_document
